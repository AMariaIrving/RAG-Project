**将第一阶段产出的、充满洞见的、但仍然是自然语言格式的《情境化需求分析报告》，转化为一台机器（我们的RAG系统）能够精确无误地理解和执行的“指令集”。**

这就像将一位战略家画出的宏伟草图，交给一位工程师，由他来绘制出每一根梁、每一颗螺丝钉都标注清晰的施工蓝图。

我们将严格遵循“极简MVP”和“手动控制”的原则，来设计`run_stage_2.py`脚本的超详细内部逻辑。

---

### `run_stage_2.py` 内部逻辑的超详细设计

**脚本总体目标:** 读取 `/01_stage_discovery/c_contextualized_req_report.txt` 文件，通过一次（或多次）精心设计的LLM调用，最终在 `/02_stage_structuring/` 文件夹下生成一份名为 `structured_req_matrix.jsonl` 的、高度结构化的文件。

---

#### **步骤 1: 环境初始化与输入读取 (Setup & Ingestion)**

*   **功能描述:** 准备工作环境，并完整地读取模块一的最终产物。
*   **详细流程:**
    1.  **路径定义:** 脚本内部定义输入文件路径 (`../01_stage_discovery/c_contextualized_req_report.txt`) 和输出路径 (`../02_stage_structuring/`)。
    2.  **输出目录检查:** 检查输出路径是否存在，如果不存在，则创建。
    3.  **输入文件读取:** 脚本打开并读取 `c_contextualized_req_report.txt` 的全部内容，将其加载到一个字符串变量中。
    4.  **预定义结构加载:** 脚本需要预先加载一个“需求分类模型”或“标签体系”。这可以是一个简单的Python字典或一个独立的配置文件（如 `config/schemas.json`）。这个文件定义了我们在设计阶段讨论过的标签，例如：
        ```json
        {
          "domains": ["生产", "仓储", "质量", "供应链", "销售", "人事", "财务"],
          "system_levels": ["ERP", "MES", "WMS", "PLM", "SCADA/IIoT", "CRM"],
          "goals": ["提升效率", "降低成本", "提高质量", "保障合规", "增强创新"]
        }
        ```
        这个“标签体系”将作为LLM执行分类任务的“强制约束词汇表”。

---

#### **步骤 2: 核心LLM调用 - 需求分解与结构化 (Core LLM Call - Decomposition & Structuring)**

*   **功能描述:** 这是本阶段的核心。通过一个极其强大和精细的Prompt，指示LLM完成从“理解”到“分解”再到“格式化输出”的一系列复杂操作。
*   **详细流程:**
    1.  **终极Prompt构建:** 这是整个脚本的灵魂。我们将设计一个“一步到位”的Prompt，要求LLM直接输出我们想要的JSONL格式。这个Prompt必须包含以下几个关键部分：
        *   **角色扮演:** "你是一个顶级的系统分析师和需求工程师。你的任务是将一份自然语言的业务需求分析报告，转换为一份给后续解决方案检索系统使用的、高度结构化的JSONL格式的需求矩阵。"
        *   **上下文注入:**
            *   "【待处理的需求分析报告】:\n[此处插入 `c_...report.txt` 的全部文本内容]"
        *   **强制词汇表约束:**
            *   "【有效的领域标签 (domains)】: [此处插入预定义的domains列表]"
            *   "【有效的系统层级标签 (system_levels)】: [此处插入预定义的system_levels列表]"
            *   "【有效的目标类型标签 (goals)】: [此处插入预定义的goals列表]"
        *   **核心任务指令与分解规则 (极其重要):**
            *   "请你通读报告，识别出所有具体的需求点，包括显性需求和隐性需求。"
            *   "**规则1 (原子化):** 每一个识别出的需求点，如果它包含多个动作或目标，必须将其拆分为多个独立的、不可再分的'原子需求'。"
            *   "**规则2 (结构化):** 对于每一个原子需求，你必须生成一个JSON对象，并严格包含以下字段..."
        *   **输出格式的精确定义 (用示例来约束):**
            *   "`req_id` (string): 生成一个'REQ-领域缩写-序号'格式的唯一ID，例如 'REQ-QUAL-001'。"
            *   "`query_sentence` (string): 将原子需求的核心内容，改写成一个清晰、完整、适合向量检索的疑问句或陈述句。这个句子必须包含足够的上下文，以便独立理解。"
            *   "`source_description` (string): 从原始报告中，摘录出能够支撑或描述这个原子需求的最相关的原文句子。"
            *   "`metadata` (object): 一个包含元数据的对象，其中必须包含以下字段..."
            *   "`metadata.domain` (array of strings): 从我提供的'有效领域标签'中，选择一个或多个最相关的标签。"
            *   "`metadata.system_level` (array of strings): 从我提供的'有效系统层级标签'中，选择相关的标签。"
            *   "`metadata.goal` (array of strings): 从我提供的'有效目标类型标签'中，选择相关的标签。"
            *   "`metadata.parameters` (object or null): 如果需求中包含可量化的指标，则提取并存放在此。例如 `{kpi: '库存周转率', current_value: '6次/年', target_value: '>10次/年'}`。如果没有，则为null。"
        *   **最终输出指令:** "请将每一个原子需求生成的JSON对象，作为JSONL格式的一行输出。每个JSON对象占一行，对象之间不要有任何逗号。不要在开头或结尾添加任何额外的解释性文字或代码块标记。"
    2.  **API调用:** 将这个巨大而精密的Prompt，**调用一次**能力最强的MOE/LLM的API。考虑到输出可能很长，需要设置一个足够大的`max_tokens`参数。
    3.  **结果解析与验证:**
        *   接收API返回的纯文本字符串。
        *   脚本需要逐行读取这个字符串。
        *   对于每一行，尝试用JSON解析器（`json.loads()`）来解析。这是一个**关键的验证步骤**。如果某一行解析失败，说明LLM没有严格遵守格式要求。
        *   **容错/重试逻辑 (可选但建议):** 如果解析失败，可以设计一个重试逻辑。例如，将失败的行和原始错误信息一起，再次提交给LLM，并指示它：“你上次的输出在这一行存在JSON格式错误，请修正它。”
    4.  **结果保存:** 将所有成功解析的行，逐行写入到最终产物文件 `/02_stage_structuring/structured_req_matrix.jsonl` 中。

---

**人工审核点（再次强调）:**
*   **您的动作:** 脚本执行完毕。您的核心工作是打开 `structured_req_matrix.jsonl` 文件。
*   **审核清单:**
    1.  **完整性:** 是否所有在原始报告中提到的关键需求，都已经被转换和包含了？有没有遗漏？
    2.  **原子性:** 每个需求点是否足够“单一”？还是仍然可以被进一步拆分？
    3.  **精确性:** `query_sentence` 是否准确地表达了需求的意图？它是否包含歧义？
    4.  **标签准确性:** `metadata` 中的标签是否打得正确？这直接影响后续RAG的检索质量。
    5.  **参数提取:** 报告中提到的KPI和量化指标，是否被准确地提取到了 `parameters` 字段中？
*   **您的权力:** **这是您作为“总指挥”最能体现价值的地方。** 如果您发现某个`query_sentence`不够好，某个标签打错了，您可以**直接在这个`.jsonl`文件中手动修改它**。您的专业修正，将直接提升后续所有步骤的质量。

这个阶段的设计，将一个极具挑战性的认知任务，通过强大的Prompt工程，变成了一个确定性的、可验证的工程步骤。