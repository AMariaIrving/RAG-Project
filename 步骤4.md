
---

### `run_stage_4.py` 内部逻辑的超详细设计

**脚本总体目标:** 整合 `/02_stage_structuring/` 和 `/03_stage_generation/` 文件夹下的所有相关信息，通过一次（或几次）极其复杂的LLM调用，最终在 `/04_stage_synthesis/` 文件夹下生成一份名为 `final_draft_v1.md` 的、可以直接阅读和交付的Markdown文档。

---

#### **步骤 1: 环境初始化与全量数据加载 (Setup & Full Data Ingestion)**

*   **功能描述:** 准备工作环境，并把前序阶段所有相关的、结构化的产物全部加载到内存中，构建一个完整的“项目上下文”。
*   **详细流程:**
    1.  **路径定义:** 脚本内部定义所有需要的输入路径（来自`02_stage...`和`03_stage...`）和最终的输出路径 (`../04_stage_synthesis/`)。
    2.  **输出目录检查:** 检查输出路径是否存在，如果不存在，则创建。
    3.  **加载需求矩阵:** 打开并逐行解析 `structured_req_matrix.jsonl`，将其加载为一个以`req_id`为键、需求对象为值的Python字典（Dictionary）。这将方便我们快速查找任何一个需求的详细信息。
    4.  **加载RAG片段:** 打开并逐行解析 `a_rag_snippets.jsonl`，同样加载为一个以`req_id`为键、RAG结果为值的字典。
    5.  **加载LLM建议:** 打开并逐行解析 `b_llm_suggestions.jsonl`，也加载为一个以`req_id`为键、LLM建议为值的字典。
    6.  **加载输出模板:** 脚本需要读取一个预先定义好的**Markdown模板文件**（例如 `templates/report_template.md`）。这个模板文件定义了最终报告的完整章节结构和标题，其中可能包含一些特殊的占位符，例如 `{{CHAPTER:QUALITY_TRACEABILITY}}`，用于指示脚本后续将生成的内容填充到哪里。

---

#### **步骤 2: 主循环 - 逐个模块生成内容 (Main Loop - Per-Module Content Generation)**

*   **功能描述:** 在这个核心步骤中，我们不尝试用一个巨大的Prompt一次性生成所有内容（这非常容易失败且难以控制）。相反，我们**遍历最终报告的章节结构**，**逐个章节地**调用LLM来生成内容。这是一种更稳健、更模块化的生成策略。
*   **详细流程:**
    1.  **确定生成单元:** 脚本根据输出模板的结构，确定需要生成内容的“单元”。一个单元可以是一个大的章节（如“4. 详细模块方案”），也可以是一个更小的子章节（如“4.1 质量追溯模块”）。
    2.  **为每个单元构建上下文:** 脚本进入一个循环，为每个待生成的单元执行以下操作：
        *   **关联需求:** 首先，确定当前单元（例如“质量追溯模块”）关联了哪些`req_id`。这可以通过`metadata`中的`domain`标签来实现。
        *   **汇集素材:** 对于每一个关联的`req_id`，从【步骤1】加载的字典中，提取出其完整的需求描述、所有的RAG片段、以及所有的LLM建议。
    3.  **调用LLM生成单元内容:**
        *   **构建子Prompt:** 为当前这个单元，动态构建一个专用的Prompt。
            *   **角色扮演:** "你是一位顶级的解决方案架构师和技术作者。"
            *   **任务指令:** "你的任务是撰写'XXX模块'的详细解决方案。请你评审并融合以下我提供的所有背景信息和素材，撰写一段逻辑连贯、内容详实、专业且易于理解的文字。你需要决定采用哪些方案，对它们进行组合和解释，并确保最终的文字是一个有机的整体，而不是简单的拼接。"
            *   **上下文注入:**
                *   "【相关需求列表】:\n[插入所有关联需求的`query_sentence`和`source_description`]"
                *   "【参考的事实方案片段(RAG)】:\n[插入所有关联的RAG片段的`content`和`source`]"
                *   "【参考的方向性建议(LLM)】:\n[插入所有关联的LLM建议的`title`和`description`]"
            *   **输出风格要求:** "请直接输出该章节的正文内容，使用Markdown语法进行必要的格式化（如列表、粗体）。不要包含章节标题，因为标题由主程序控制。"
        *   **API调用:** 调用强大的MOE/LLM API。
    4.  **暂存生成内容:** 将LLM返回的该单元的Markdown内容，与模板中的占位符（如`{{CHAPTER:QUALITY_TRACEABILITY}}`）关联起来，存储在一个临时的结果字典中。

---

#### **步骤 3: 全文合成与最终渲染 (Full Synthesis & Final Rendering)**

*   **功能描述:** 在所有独立的内容单元都生成完毕后，将它们组装成一篇完整的文档，并进行最后的处理。
*   **详细流程:**
    1.  **加载模板:** 脚本再次读取【步骤1】中的Markdown模板文件的内容。
    2.  **内容替换:** 遍历【步骤2】中存储生成结果的字典。对于每一个占位符，用其对应的、由LLM生成的Markdown内容，替换掉模板中的占位符。
    3.  **（可选）生成全局摘要/引言:** 脚本可以再次调用一次LLM，将所有生成好的章节内容作为输入，并指示它：“请为以下完整的解决方案报告，撰写一段200字的执行摘要（Executive Summary）和一段引言。”然后将生成的内容，替换掉模板中对应的`{{EXECUTIVE_SUMMARY}}`占位符。
    4.  **最终处理:**
        *   **引用标注:** 脚本可以实现一个逻辑，在替换内容的同时，查找文本中可能被LLM隐式引用的来源，并添加`[cite]`标记。
        *   **占位符处理:** 扫描最终文本，列出所有图片/图表的占位符（如`[IMAGE:...]`），您可以后续根据这个列表来手动配图。
    5.  **写入文件:** 将经过完整合成和处理的、最终的Markdown长文本，写入到目标文件 `/04_stage_synthesis/final_draft_v1.md`。

---

**人工审核点（最终交付）:**
*   **您的动作:** 这是激动人心的时刻。脚本执行完毕，您现在可以打开 `/04_stage_synthesis/final_draft_v1.md`。
*   **审核清单:**
    1.  **流畅性与连贯性:** 整篇报告读起来是否像一个专家一气呵成写出来的？章节之间的过渡是否自然？
    2.  **逻辑性:** 方案的整体架构是否合理？各个模块之间的关系是否解释清楚了？
    3.  **准确性:** 是否有明显的“幻觉”或与RAG事实相悖的内容？
    4.  **完整性:** 是否覆盖了第二阶段提出的所有核心需求？
    5.  **格式:** Markdown格式是否正确、美观？
*   **您的权力:** 这是最终的交付物。您可以直接在这个Markdown文件上进行修改、润色、补充您自己的专业洞见，或者添加图表。这份由AI生成的80%的初稿，将成为您高效完成最终100%完美方案的坚实基础。


