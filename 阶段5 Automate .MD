好的，我们正式进入**阶段5: Automate (自动化执行阶段)**。

这是整个流程中最激动人心的部分，我们将亲眼见证设计图纸变为现实。在这个阶段，您的角色将从“设计师”和“审批官”转变为“**施工队长**”。您负责分发任务、监督施工（由Claude完成），并进行现场的组装和调试。

---

### **阶段5: Automate (自动化执行阶段)**

**核心原则:**
*   **一次只做一个任务:** 严格按照`TASK_stage1.md`的顺序，逐个击破。
*   **上下文要给足:** 给AI的指令，永远要包含足够的背景信息。
*   **小步快跑，持续验证:** 每完成一小段代码，就尝试运行一下，确保它是正确的。

**您的工作环境:**
*   左边屏幕：您的代码编辑器，打开`scripts/run_stage_1.py`文件。
*   右边屏幕：Claude Code模型的聊天窗口。

---

#### **执行`TASK_stage1.md`中的原子任务**

**任务1: 环境设置与主流程搭建**

*   **您的动作:** 这是第一个任务，也是唯一一个您可能需要自己动手比AI更快的任务。当然，我们依然可以遵循流程。

> **Prompt to Claude:**
>
> 你好，我们开始为`run_stage_1.py`编写代码。这是我们的任务清单`TASK_stage1.md`中的第一个任务：
>
> **【粘贴 `TASK_stage1.md` 中“任务1”的全部描述】**
>
> 这是我们的架构设计`DESIGN_stage1.md`中定义的函数签名：
>
> **【粘贴 `DESIGN_stage1.md` 中所有函数的定义部分】**
>
> 请根据以上要求，为我生成`run_stage_1.py`的初始骨架代码。

*   **Claude的预期输出:** 一个包含所有空函数和`main`函数调用流程的完整Python脚本。
*   **您的后续动作:**
    1.  **复制 & 粘贴:** 将Claude生成的代码完整地复制到您的`run_stage_1.py`文件中。
    2.  **验证:** 在命令行中运行`python scripts/run_stage_1.py`。您应该能看到脚本顺利执行，并依次打印出每一步的提示信息，然后正常退出。
    3.  **确认完成:** 任务1完成。我们的“骨架”搭好了。

**任务2: 实现 `ingest_raw_data` 函数**

*   **您的动作:** 现在我们来填充第一个函数。

> **Prompt to Claude:**
>
> 好的，我们继续。现在请为`ingest_raw_data`函数编写具体的实现代码。
>
> 这是它的任务描述：
> **【粘贴 `TASK_stage1.md` 中“任务2”的全部描述】**
>
> 这是它在代码骨架中的位置和函数签名：
> **【粘贴 `run_stage_1.py` 中 `ingest_raw_data` 的空函数代码】**
>
> 请注意，对于处理.docx和.pdf文件，你可能需要引入`python-docx`和`PyMuPDF`库。请在代码注释中提醒我需要安装这些依赖。对于音视频处理，暂时先用一个`print`语句作为占位符即可。

*   **Claude的预期输出:** `ingest_raw_data`函数的完整Python代码。
*   **您的后续动作:**
    1.  **安装依赖:** 根据Claude的提示，在您的虚拟环境中运行 `pip install python-docx PyMuPDF`。
    2.  **替换代码:** 将您文件中空的`ingest_raw_data`函数，替换为Claude生成的完整代码。
    3.  **单元测试/验证:**
        *   在`/00_input/`文件夹里放几个测试文件（一个.txt,一个.docx,一个.jpg）。
        *   **临时修改**`main`函数，让它只调用`ingest_raw_data`并打印返回结果。
        *   运行脚本，检查打印出的字典是否包含了正确提取的文本和图片路径。
    4.  **确认完成:** 任务2完成。

**任务3: 实现 `summarize_raw_info` 函数**

*   **您的动作:** 填充第二个函数。

> **Prompt to Claude:**
>
> 非常好。接下来我们实现`summarize_raw_info`函数。
>
> 这是任务描述：
> **【粘贴 `TASK_stage1.md` 中“任务3”的全部描述】**
>
> 这是它的函数签名：
> **【粘贴空函数代码】**
>
> 假设我已经有了一个名为`call_moe_llm(prompt)`的辅助函数，它负责处理API调用。你只需要关注如何构建正确的Prompt并调用它即可。对于图片，暂时假设我们通过路径传递给API。

*   **Claude的预期输出:** `summarize_raw_info`函数的完整Python代码。
*   **您的后续动作:**
    1.  **替换代码:** 将生成的代码放入`run_stage_1.py`。
    2.  **实现辅助函数:** 您需要自己编写（或让Claude帮您编写）那个`call_moe_llm`的辅助函数，里面包含您真实的API Key和调用逻辑。
    3.  **集成测试:** 恢复`main`函数对`ingest_raw_data`和`summarize_raw_info`的调用。运行脚本。检查`/01_stage_discovery/`文件夹下是否正确生成了`a_raw_info_summary.txt`文件，并且内容看起来合理。
    4.  **确认完成:** 任务3完成。

**任务4 & 任务5: (以此类推)**

您将重复以上模式，逐个完成`retrieve_macro_context`和`synthesize_final_report`函数的实现。

*   **Prompt结构永远是:**
    1.  清晰的指令：“现在我们实现 XXX 函数。”
    2.  任务上下文：“这是`TASK.md`里对它的描述...”
    3.  代码上下文：“这是它在文件里的空函数签名...”
    4.  必要的假设和约束：“假设已有XXX辅助函数...”、“暂时用XXX作为占位符...”。

---

**完成所有任务后**

当`TASK_stage1.md`中的所有任务都已编码、替换并经过单元验证后，您就有了一个初步完整的`run_stage_1.py`脚本。

**最后的集成测试:**
1.  **清理环境:** 清空`/01_stage_discovery/`文件夹。
2.  **完整运行:** 在命令行执行 `python scripts/run_stage_1.py`。
3.  **端到端验证:** 观察控制台的打印信息是否流畅，然后检查`/01_stage_discovery/`下的三个产物文件是否都已生成，并且内容符合预期。

至此，Automate阶段的核心工作就完成了。我们已经将设计转化为了可工作的代码。

---

接下来，我们将进入最后一个阶段：**Assess (评估阶段)**，对我们的劳动成果进行最终的质量验收。